1. JAVA에 관하여
1. 변수
   1. 상수와 리터럴(constant & literal)
      - 상수 : 값을 한번만 저자알 수 있는 공간으로써 반드시 선언과 동시에 초기화해야 하며, 그 후 부터는 상수의 값을 변경할 수 없다.
      - 리터럴 : 그 자체로 값을 의미하는 것
      
         ![](/img/java1.PNG)
1. 연산자
   1. 우선순위
   
   종류 | 연산자 | 우선순위
   ---- | ---- | ----
   단항 연산자 | ++ -- + - ~ ! (type) | 높음
   산술 연산자 | * / % + - << >>
   비교 연산자 | < > <= >= instanceof
   논리 연산자 | & \| ^  && \|\|
   삼항 연산자 | ?:
   대입 연산자 | = += -= *= /= %= <<= >>= &= ^=  \|= | 낮음
   
1. 객체지향
   * 클래스 : 객체를 정의해 놓은 것
   * 클래스로부터 객체를 만드는 과정을 인스턴스화라고 하며 그로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
   * 변수와 메서드
   
   변수의 종류 | 선언위치 | 생성시기
   ---- | ---- | ----
   클래스변수 | 클래스영역 | 클래스가 메모리에 올라갈 때
   인스턴스변수 | 클래스영역 | 인스턴스가 생성되었을 때
   지역변수 | 클래스 영역 이외의 영역<br>(메서드, 생성자, 초기화 블럭 내부) | 변수 선언문이 수행되었을 때
   
   * JVM의 메모리 구조
   
   ![](/img/java2.png)
   
   1. 메서드 영역(method area)
      - 프로그램 실행 중 어떤 클래스가 사용되면 JVM은 해당 클래사의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수(class variable)들이 생성되는 공간이다.
   1. 힙(heap)
      - 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수들이 생성되는 공간이다.
   1. 호출스택(call stack or execcution stack)
      - 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.
   </br>
   
   * 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다. (read only)
   * 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다. (read & write) ex) 배열도 참조형

### overloading & overriding
* 오버로딩(overloading)
   - 하나의 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 존재하여 중복해서 사용할 경우. 메서드 이름이 같고 매개변수의 개수 또는 타입이 달라야 한다.
* 오버라이딩(overriding)
   - 상위 클래스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것을 의미한다. 부모클래스와 이름, 매개변수, 반환타입이 같아야하고 접근제어자는 조상클래스보다 좁은 범위로 변경할 수 없다.
   
* 오버라이딩 예제
```java
class BindingTest3{
 public static void main(String[] args) {
  Parent p = new Child();
  Child  c = new Child();
 
  System.out.println("p.x = " + p.x);
  p.method();
  System.out.println();
  System.out.println("c.x = " + c.x);
  c.method();
 }
}
 
class Parent {
 int x = 100;
 
 void method() {
  System.out.println("Parent Method");
 }
}
 
class Child extends Parent {
 int x = 200;
 
 void method() {
  System.out.println("x=" + x);  // this.x와 같다.
  System.out.println("super.x=" + super.x);
  System.out.println("this.x="  + this.x);
 }
}

출력 결과 : 

p.x = 100
x=200
super.x=100
this.x=200

c.x = 200
x=200
super.x=100
this.x=200
```
### 생성자

* 인스턴스 초기화할 목적으로 사용
* 생성자 조건
   1. 생성자의 이름은 클래스 이름과 같아야 한다.
   1. 생성자는 리턴값이 없다.
* 생성자는 new 할때 처음이자 마지막으로 한 번만 수행된다.
* 명시적 vs 묵시적
* 눈에 보인다 vs 눈에 보이지 않는다.
* this();  -> 다른 생성자 호출
* this() 키워드는 무조건 생성자 안에서 첫 번째에서만 사용이 가능하다.

### 패키지
* 서로 관련이 있는 클래스들의 묶음

### this, super, 메모리의 4원칙, 다형성 3대 발생원리
* this() -> 생성자 호출
* super() -> 상위 클래스의 생성자 호출

ex)
```java
Point3D(){

super();

system.out.println();

}
```
-> 생성자에서는 super나 this는 무조건 첫째줄에서 초기화 해줘야 한다. print문이 먼저 쓰일경우 에러
-> 하나의 생성자에는 this나 super 둘 중 쓰일 경우엔 하나만 쓸 수 있다. 하나의 생성자에 두 개의 명령어를 동시에 사용할 수 없다.

* 메모리의 4 원칙
   - 생주부주 : 생성된 주소는 부모의 주소를 가르킨다.
   - 자생부생 : 자식이 생성되었다면 부모가 먼저 생성된다.
   - 자설부설 : 자식의 설계도가 올라가면 부모의 설계도도 존재한다.
   - 설공매사 : 설계도에 공개된 메서드만 사용가능하다.

* 다형성 3대 발생원리
   - 부타자참 : 부모의 타입으로 자식을 참조할 수 있다.
   - 부타자생 : 부모의 타입으로 자식 생성 가능
   - 부메자호 : 부모의 메서드로 자식의 메서드 호출 가능
